/**  * Gestionnaire de connexions Prisma multiples pour isolation par organisation  * Permet d'avoir une base de donnâ”œâŒes sâ”œâŒparâ”œâŒe par organisation pour une sâ”œâŒcuritâ”œâŒ maximale  */  import { PrismaClient } from "@prisma/client";  // Cache des instances Prisma par organisation const prismaClients = new Map<string, PrismaClient>();  // Instance par dâ”œâŒfaut (pour la base principale qui contient les organisations) const globalForPrisma = globalThis as unknown as {   defaultPrisma: PrismaClient | undefined; };  // Instance Prisma pour la base principale (mâ”œâŒtadonnâ”œâŒes des organisations) export const defaultPrisma =   globalForPrisma.defaultPrisma ??   new PrismaClient({     log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],     datasources: {       db: {         url: process.env.DATABASE_URL,       },     },   });  if (process.env.NODE_ENV !== "production") {   globalForPrisma.defaultPrisma = defaultPrisma; }  /**  * Râ”œâŒcupâ”œÂ¿re l'URL de la base de donnâ”œâŒes pour une organisation  * Si l'organisation a une databaseUrl configurâ”œâŒe, l'utilise  * Sinon, utilise la DATABASE_URL par dâ”œâŒfaut (mode partagâ”œâŒ)  */ async function getOrganizationDatabaseUrl(organizationId: string): Promise<string> {   try {     const organization = await defaultPrisma.organization.findUnique({       where: { id: organizationId },       select: { databaseUrl: true },     });      // Si l'organisation a sa propre base de donnâ”œâŒes     if (organization?.databaseUrl) {       return organization.databaseUrl;     }      // Sinon, utiliser la base par dâ”œâŒfaut (mode partagâ”œâŒ)     return process.env.DATABASE_URL || "";   } catch (error) {     console.error(`Error fetching database URL for organization ${organizationId}:`, error);     // Fallback vers la base par dâ”œâŒfaut     return process.env.DATABASE_URL || "";   } }  /**  * Obtient ou crâ”œâŒe une instance PrismaClient pour une organisation spâ”œâŒcifique  */ export async function getPrismaForOrganization(   organizationId: string | null ): Promise<PrismaClient> {   // Si pas d'organisation, utiliser l'instance par dâ”œâŒfaut   if (!organizationId) {     return defaultPrisma;   }    // Vâ”œâŒrifier si on a dâ”œâŒjâ”œÃ¡ une instance en cache   if (prismaClients.has(organizationId)) {     return prismaClients.get(organizationId)!;   }    // Râ”œâŒcupâ”œâŒrer l'URL de la base pour cette organisation   const databaseUrl = await getOrganizationDatabaseUrl(organizationId);    // Si c'est la mâ”œÂ¬me URL que la base par dâ”œâŒfaut, râ”œâŒutiliser l'instance   if (databaseUrl === process.env.DATABASE_URL) {     prismaClients.set(organizationId, defaultPrisma);     return defaultPrisma;   }    // Crâ”œâŒer une nouvelle instance PrismaClient pour cette organisation   const prisma = new PrismaClient({     log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],     datasources: {       db: {         url: databaseUrl,       },     },   });    // Mettre en cache   prismaClients.set(organizationId, prisma);    return prisma; }  /**  * Nettoie les connexions Prisma (utile pour les tests ou le redâ”œâŒmarrage)  */ export async function disconnectAllPrismaClients(): Promise<void> {   await Promise.all(     Array.from(prismaClients.values()).map((client) => client.$disconnect())   );   await defaultPrisma.$disconnect();   prismaClients.clear(); }  /**  * Vâ”œâŒrifie si une organisation utilise une base de donnâ”œâŒes dâ”œâŒdiâ”œâŒe  */ export async function hasDedicatedDatabase(organizationId: string): Promise<boolean> {   try {     const organization = await defaultPrisma.organization.findUnique({       where: { id: organizationId },       select: { databaseUrl: true },     });     return !!organization?.databaseUrl;   } catch {     return false;   } }