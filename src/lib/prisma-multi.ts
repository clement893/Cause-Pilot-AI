/**  * Gestionnaire de connexions Prisma multiples pour isolation par organisation  * Permet d'avoir une base de donnÃ¢â€Å“Ã¢Å’Âes sÃ¢â€Å“Ã¢Å’ÂparÃ¢â€Å“Ã¢Å’Âe par organisation pour une sÃ¢â€Å“Ã¢Å’ÂcuritÃ¢â€Å“Ã¢Å’Â maximale  */  import { PrismaClient } from "@prisma/client";  // Cache des instances Prisma par organisation const prismaClients = new Map<string, PrismaClient>();  // Instance par dÃ¢â€Å“Ã¢Å’Âfaut (pour la base principale qui contient les organisations) const globalForPrisma = globalThis as unknown as {   defaultPrisma: PrismaClient | undefined; };  // Instance Prisma pour la base principale (mÃ¢â€Å“Ã¢Å’ÂtadonnÃ¢â€Å“Ã¢Å’Âes des organisations) export const defaultPrisma =   globalForPrisma.defaultPrisma ??   new PrismaClient({     log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],     datasources: {       db: {         url: process.env.DATABASE_URL,       },     },   });  if (process.env.NODE_ENV !== "production") {   globalForPrisma.defaultPrisma = defaultPrisma; }  /**  * RÃ¢â€Å“Ã¢Å’ÂcupÃ¢â€Å“Ã‚Â¿re l'URL de la base de donnÃ¢â€Å“Ã¢Å’Âes pour une organisation  * Si l'organisation a une databaseUrl configurÃ¢â€Å“Ã¢Å’Âe, l'utilise  * Sinon, utilise la DATABASE_URL par dÃ¢â€Å“Ã¢Å’Âfaut (mode partagÃ¢â€Å“Ã¢Å’Â)  */ async function getOrganizationDatabaseUrl(organizationId: string): Promise<string> {   try {     const organization = await defaultPrisma.organization.findUnique({       where: { id: organizationId },       select: { databaseUrl: true },     });      // Si l'organisation a sa propre base de donnÃ¢â€Å“Ã¢Å’Âes     if (organization?.databaseUrl) {       return organization.databaseUrl;     }      // Sinon, utiliser la base par dÃ¢â€Å“Ã¢Å’Âfaut (mode partagÃ¢â€Å“Ã¢Å’Â)     return process.env.DATABASE_URL || "";   } catch (error) {     console.error(`Error fetching database URL for organization ${organizationId}:`, error);     // Fallback vers la base par dÃ¢â€Å“Ã¢Å’Âfaut     return process.env.DATABASE_URL || "";   } }  /**  * Obtient ou crÃ¢â€Å“Ã¢Å’Âe une instance PrismaClient pour une organisation spÃ¢â€Å“Ã¢Å’Âcifique  */ export async function getPrismaForOrganization(   organizationId: string | null ): Promise<PrismaClient> {   // Si pas d'organisation, utiliser l'instance par dÃ¢â€Å“Ã¢Å’Âfaut   if (!organizationId) {     return defaultPrisma;   }    // VÃ¢â€Å“Ã¢Å’Ârifier si on a dÃ¢â€Å“Ã¢Å’ÂjÃ¢â€Å“ÃƒÂ¡ une instance en cache   if (prismaClients.has(organizationId)) {     return prismaClients.get(organizationId)!;   }    // RÃ¢â€Å“Ã¢Å’ÂcupÃ¢â€Å“Ã¢Å’Ârer l'URL de la base pour cette organisation   const databaseUrl = await getOrganizationDatabaseUrl(organizationId);    // Si c'est la mÃ¢â€Å“Ã‚Â¬me URL que la base par dÃ¢â€Å“Ã¢Å’Âfaut, rÃ¢â€Å“Ã¢Å’Âutiliser l'instance   if (databaseUrl === process.env.DATABASE_URL) {     prismaClients.set(organizationId, defaultPrisma);     return defaultPrisma;   }    // CrÃ¢â€Å“Ã¢Å’Âer une nouvelle instance PrismaClient pour cette organisation   const prisma = new PrismaClient({     log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],     datasources: {       db: {         url: databaseUrl,       },     },   });    // Mettre en cache   prismaClients.set(organizationId, prisma);    return prisma; }  /**  * Nettoie les connexions Prisma (utile pour les tests ou le redÃ¢â€Å“Ã¢Å’Âmarrage)  */ export async function disconnectAllPrismaClients(): Promise<void> {   await Promise.all(     Array.from(prismaClients.values()).map((client) => client.$disconnect())   );   await defaultPrisma.$disconnect();   prismaClients.clear(); }  /**  * VÃ¢â€Å“Ã¢Å’Ârifie si une organisation utilise une base de donnÃ¢â€Å“Ã¢Å’Âes dÃ¢â€Å“Ã¢Å’ÂdiÃ¢â€Å“Ã¢Å’Âe  */ export async function hasDedicatedDatabase(organizationId: string): Promise<boolean> {   try {     const organization = await defaultPrisma.organization.findUnique({       where: { id: organizationId },       select: { databaseUrl: true },     });     return !!organization?.databaseUrl;   } catch {     return false;   } }