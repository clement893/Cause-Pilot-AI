/**  * Gestionnaire de connexions Prisma multiples pour isolation par organisation  * Permet d'avoir une base de donn├⌐es s├⌐par├⌐e par organisation pour une s├⌐curit├⌐ maximale  */  import { PrismaClient } from "@prisma/client";  // Cache des instances Prisma par organisation const prismaClients = new Map<string, PrismaClient>();  // Instance par d├⌐faut (pour la base principale qui contient les organisations) const globalForPrisma = globalThis as unknown as {   defaultPrisma: PrismaClient | undefined; };  // Instance Prisma pour la base principale (m├⌐tadonn├⌐es des organisations) export const defaultPrisma =   globalForPrisma.defaultPrisma ??   new PrismaClient({     log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],     datasources: {       db: {         url: process.env.DATABASE_URL,       },     },   });  if (process.env.NODE_ENV !== "production") {   globalForPrisma.defaultPrisma = defaultPrisma; }  /**  * R├⌐cup├¿re l'URL de la base de donn├⌐es pour une organisation  * Si l'organisation a une databaseUrl configur├⌐e, l'utilise  * Sinon, utilise la DATABASE_URL par d├⌐faut (mode partag├⌐)  */ async function getOrganizationDatabaseUrl(organizationId: string): Promise<string> {   try {     const organization = await defaultPrisma.organization.findUnique({       where: { id: organizationId },       select: { databaseUrl: true },     });      // Si l'organisation a sa propre base de donn├⌐es     if (organization?.databaseUrl) {       return organization.databaseUrl;     }      // Sinon, utiliser la base par d├⌐faut (mode partag├⌐)     return process.env.DATABASE_URL || "";   } catch (error) {     console.error(`Error fetching database URL for organization ${organizationId}:`, error);     // Fallback vers la base par d├⌐faut     return process.env.DATABASE_URL || "";   } }  /**  * Obtient ou cr├⌐e une instance PrismaClient pour une organisation sp├⌐cifique  */ export async function getPrismaForOrganization(   organizationId: string | null ): Promise<PrismaClient> {   // Si pas d'organisation, utiliser l'instance par d├⌐faut   if (!organizationId) {     return defaultPrisma;   }    // V├⌐rifier si on a d├⌐j├á une instance en cache   if (prismaClients.has(organizationId)) {     return prismaClients.get(organizationId)!;   }    // R├⌐cup├⌐rer l'URL de la base pour cette organisation   const databaseUrl = await getOrganizationDatabaseUrl(organizationId);    // Si c'est la m├¬me URL que la base par d├⌐faut, r├⌐utiliser l'instance   if (databaseUrl === process.env.DATABASE_URL) {     prismaClients.set(organizationId, defaultPrisma);     return defaultPrisma;   }    // Cr├⌐er une nouvelle instance PrismaClient pour cette organisation   const prisma = new PrismaClient({     log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],     datasources: {       db: {         url: databaseUrl,       },     },   });    // Mettre en cache   prismaClients.set(organizationId, prisma);    return prisma; }  /**  * Nettoie les connexions Prisma (utile pour les tests ou le red├⌐marrage)  */ export async function disconnectAllPrismaClients(): Promise<void> {   await Promise.all(     Array.from(prismaClients.values()).map((client) => client.$disconnect())   );   await defaultPrisma.$disconnect();   prismaClients.clear(); }  /**  * V├⌐rifie si une organisation utilise une base de donn├⌐es d├⌐di├⌐e  */ export async function hasDedicatedDatabase(organizationId: string): Promise<boolean> {   try {     const organization = await defaultPrisma.organization.findUnique({       where: { id: organizationId },       select: { databaseUrl: true },     });     return !!organization?.databaseUrl;   } catch {     return false;   } }